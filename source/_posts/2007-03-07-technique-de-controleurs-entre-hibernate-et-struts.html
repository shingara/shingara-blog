---
layout: post
title: Technique de controleurs entre Hibernate et Struts
typo_id: 40
---
<p>
	Dans un précédent <a
href="http://shingara.free.fr/blog/index.php/?2007/01/16/138-hibernate-et-les-
mappings">billet sur Hibernate et les mappings</a>, je me posais la question de
savoir comment séparer au maximum chaques fonctions dans une application J2EE
utilisant <a href="http://www.hibernate.org/">Hibernate</a> et <a href="http://struts.apache.org/">Struts</a>. Voici donc la
technique que j'ai fini par adopter, après réflexion. Cette technique est ma
propre technique et n'est peut-être pas la meilleure.
</p>

<h1>Contexte</h1>

<p>
Dans une application J2EE utilisant Hibernate et Struts, nous utilisons
classiquement 3 composants:
</p>

<ul>
	<li>Les mappings Hibernate</li>
	<li>Les DAO (Database Access Object) pour toutes les communications à la
base de donnée</li>
	<li>Les actions Struts pour la gestion des requêtes HTTP de
l'utilisateur</li>
</ul>

<p>
Mais voilà avec ces 3 composants, les actions struts doivent utiliser
les mappings Hibernate et les DAO. les DAO eux devront utiliser les
mappings. Comme indiqué dans le schéma suivant :</p>

<p><img src="/blog/images/DAO-MAPPING-STRUTS.png" alt="Graphique représentant la communication DAO, Mapping et Action Struts" /></p>

<p>Il manque donc un composant intermédiaire entre les DAO et les
mappings qui sera le composant à être utilisé par les actions Struts. ce
composant est appelé «Controleur».
</p>

<h1>Les controleurs</h1>

<p>
Le but du controleur est de faire la liaison entre le mapping Hibernate et
le DAO. En effet, le mapping doit être un objet le plus léger possible et
n'avoir en conséquence que des attributs et leurs getter/setter. Par contre, les
DAO ne stocke rien à part la Session de connection à la base de donnée. Ainsi
le controleur n'a pour seul champ privé obligatoire que le mapping. On peux
aussi lui adjoindre des données complémentaires qui seront issues de
contraintes annexes et ainsi augmenter les possibilités d'attribut interne à la
classe. Mais des méthodes de confort pourront aussi lui être ajoutées comme la
méthode classique du save() qui se chargera de sauvegarder le mapping Hibernate
dans la session du DAO. Il aura ainsi plusieurs constructeurs avec différentes
possibilités. Par contre, il faudra faire attention au getter/setter de attribut
qui ne sont pas issue du mapping et qui peuvent dépendre du constructeur. Une
bonne gestion des erreurs et à prévoir. Ce système permet ainsi l'utilisation
unique du controleur dans l'actions Struts. Celui-ci n'aura qu'à construire
l'objet et l'utiliser. L'action Struts n'aura plus aucun dialogue avec les
mappings et DAO. Comme montré sur le schéma suivant :</p>

<p><img src="/blog/images/DAO-MAPPING-STRUTS-CONTROLER.png" alt="Graphique représentant la communication DAO, Mapping, Action Struts et Controleur" /></p>

<h1>Cas des listes de mapping Hibernates</h1>

<p>
Dans certain cas, on veux avoir une information supplémentaire à un
mapping et pour cela on utiliser les controleurs. Mais cette information peux
nécessité un calcul. Hors, au niveau du DAO, nous ne récupérons qu'une liste
d'objet de
mapping. Pour ajouter des informations, il faudrait alors itérer sur tous les
éléments et leur ajouter les éléments voulus. Cette technique n'est pas optimum
dans le cas d'une utilisation partielle de la liste, comme avec l'utilisation de
<a href="http://displaytag.sourceforge.net/11/">Display Tag</a> qui n'affichera
pas toutes les lignes et créera une pagination. La
technique est donc de créer un objet héritant de ArrayList et de surcharger la
méthode get(int). Au moment de l'appel de cette méthode, nous ne renvoyons plus
de mapping, mais notre controleur se construit à partir d'une liste d'objet
mapping. Le calcul des informations supplémentaires ne se fera donc plus que
sur les objets réelement demandé et non sur tous les objets de la liste
initiale.
</p>

<h1>Pourquoi cette implémentation ?</h1>

<p>
Je voulais par cette méthode n'obtenir que des objets le plus léger possible.
En effet, je préfére que mon programme utilise plus de petits objets que moins
d'objets, mais gros. Je voulais aussi que mes actions Struts soit le plus simple
possible à lire. Car sans l'utilisation de ce procédé, je me retrouvais avec
des actions comprenant énormément de ligne de code. Cette technique rend le
code plus simple à lire et à comprendre. Je voulais aussi effectuer les
traitements non nécessaire qu'à la fin pour ainsi permettre de n'effectuer que
le nécessaire et éviter ainsi le superflu.
</p>

<p>Pour les curieux, j'ai fait mes graphiques grâce à Graphivz que je ne maitrise hélas pas trop. Vous pouvez trouver les sources des scripts de création <a href="/exportation/script/dot/">ici</a></p>
